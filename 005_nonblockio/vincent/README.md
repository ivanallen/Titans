### 1. block_io 为什么会阻塞？

答：因为文件默认是以阻塞的方式打开的，在一个阻塞的`fd`上调用`read`，操作系统会把进程置为阻塞态。只有当有数据到达(或者出错)的时候，`read`调用才会返回。

### 2.block_io_ex 为什么无法并发处理两个不同设备来的数据?

答：`blocl_io_ex`程序以阻塞的方式打开所有文件，因此只能按顺序处理从各个文件读取的数据，只要有任意一个文件没有数据产生，程序就会陷入阻塞，后面的文件即使有数据也不能得到处理。

### 3.查阅手册，fcntl 各个参数以及返回值的含义是什么？

```C
#include<unistd.h>
int fcntl(int fd, int cmd, ... /* int arg */);
                返回值：如果成功，依赖于cmd，如果出错，返回-1
```

`fcntl`函数的功能是改变已经打开的文件的属性，具体如下：

- 复制已有的文件描述符
- 获取/设置文件描述符标志位
- 获取/设置文件状态标志(`set_nonblock`函数用到了这个功能)
- 获取/设置异步I/O所有权
- 获取/设置记录锁

### 4.你觉得非阻塞 IO 解决了什么问题？

使用非阻塞IO避免了进程被某一个一直没有数据的文件阻塞住，所有文件只要有数据进来，都可以得到及时处理。

### 5.nonblock_io 会有什么问题？

如果所有文件都一直没有数据的话，会空耗CPU。在我们的程序中使用了`sleep`函数让出CPU给其他进程，但是这样会造成数据处理不及时的问题，影响效率。这个问题可以通过使用`select`、`poll`或`epoll`等IO多路复用来解决。

### 6.学习本节需要注意的问题

1. 本节实验需要在一个非共享文件夹下面操作。如果使用虚拟机共享文件夹，`mkfifo`命令会执行不成功，不能创建命名管道。

2. 如果使用`xshell`等工具连接`linux`系统， 在执行`./block_io_ex /dev/tty allen.fifo`时，需要将`/dev/tty`替换成自己的设备。可以使用`who am i`命令查看当前设备。比如在我的机器上执行`who am i`，结果是

    ```shell
    root     pts/0        2019-06-30 01:02 (192.168.48.1)
    ```

    因此，运行程序应该输入`./block_io_ex /dev/pts/0 allen.fifo`
