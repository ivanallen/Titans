## 003_copy

经过一周的练习，不知道你和**系统调用**这位小伙伴的关系搞好没。和它做好朋友，你将事半功倍。

从现在开始，我们要正式学习 Linux 中最核心的知识之一——文件 IO.

在学完文件 IO 的知识以后，你就可以自由的使用文件 IO 相关的系统调用来操作各种文件啦。

### 1. 文件 IO

咱们来谈谈什么是文件 IO. 在 Linux 中，有种说法就是“一切皆文件”。学过 Java 的朋友肯定也会想起，“一切皆对象”。不过这两者之间除了句法是一样的，并没有其它什么关系。

Linux 的这种思想有个好处，即统一接口。这是什么意思呢？我们从文件本身的特性来谈谈。

通常来说，文件具有下面几个特点：

- 可以向它写入字节数据
- 可以从中读取字节数据
- 通常有一个可调节位置的读写指针

再举几个例子：1) 比如说你磁盘上的文件，你可以操作一些函数，向其中写入数据，也可以读取其中的数据 2) 再比如上节你使用 write 函数向屏幕输出字符，在这里，屏幕是一个很特殊的文件。3) 比如键盘，你可以从键盘读取数据，通常键盘被我们称为标准输入。

无论你是向屏幕写入数据，还是向文件写入数据，你都可以使用 `write` 这个系统调用。你不必为了区分设备的类型，而调用不同的函数。

无论是从磁盘文件读取数据，还是从键盘读取数据，你都可以使用 `read` 这个系统调用，道理是一样的，Linux 都把它们视为文件。

假如说，以后让你写个 Linux 程序来控制机器人，那道理是不是一样呢？你可以使用 `read`， `write` 函数来控制机器人的动作，是不是非常方便？

Linux 之所以能做到这一点，是因为在内核设置了一层驱动，在驱动程序里，帮你屏蔽了各种细节，因此作为应用层的使用者，根本无需关心驱动层的实现。

### 2. 文件描述符（File Descriptor）

现在我还不打算深入的去讲解“文件描述符”内部的实现原理，我只讲讲它的概念。

文件描述符，通常我们会简单的称其为 fd，也就是 File Descriptor 的缩写，因为在服务器开发里它太常见了。甚至你会经常听到，fd 泄露，fd 暴涨这些奇怪的术语。所以以后我也会使用 fd。

描述符，这个词在计算机领域你以后会经常见到。它通常来说表示某种数据结构，这个数据结构用来描述相关的对象。如果你听说过“进程控制块”，那你可以简单的认为，它是关于进程的描述符。当然，你在 OS 上编程，操作系统当然不会直接把“进程控制块”的指针直接给你用，而是以进程 id 的方式给你使用，这样就屏蔽了内核中相关的细节了。

文件描述符也是一样，在 OS 层面，它只是以一个整数的形式提供给你使用，当你使用系统调用的时候，你把这个整数传递给系统调用，到到 OS 内核，就能根据这个整数找到相关的数据结构，而这个数据结构，正是用来描述文件的。

比如，任务二里的数字 1，也就是 `STDOUT_FILENO`，当你将此数据结构传递给 `write`，经过 `int 0x80` 或者 `syscall` 指令陷入内核后，内核中的程序就可以找到一个数据结构，它里面包含了一些关于屏幕当前相关的信息。

### 3. 文件相关的系统调用

本文件你将使用使用到 `open`，`read`，`write`，`close` 这三个函数。

- `open`

如果你想往本地磁盘某个文件写入数据，首先你得拿到关于这个文件被打开后的 fd，你可以使用 `open` 函数。`open` 函数不仅可以打开文件，也可以用来创建文件。它的使用方式非常丰富，具体你可以使用 `man 2 open` 进行查阅。

例如，你可以通过调用：

```c
int srcfd = open("README.md", O_RDONLY);
```

以只读的方式来打开 README.md 文件，同时 `open` 函数返回一个描述符保存在 `srcfd` 这个变量中。

如果你调用：

```c
int dstfd = open("file", O_CREAT | O_WRONLY, 0666);
```

它表示以只写的方式创建或打开一个名为 "file" 的文件。

- `write` 和 `read`

`write` 在上一个任务里，你已经基本了解了它的使用方法。`read` 表示从文件里读取数据，具体使用方法还是使用 `man` 手册来查阅。

- `close`

`close` 表示关闭文件描述符。它的意思是，如果你不再对这个文件进行操作，应该即时的释放掉内核中关于文件描述符相关的资源。如果你只 `open` 而不做 `close`，系统资源将会被耗尽，也就是产生 fd 泄露的问题。

### 4. 任务

到了最关键的时候了。你需要 `open`，`read`，`write` 和 `close` 这四个系统调用来实现一个程序`mycp`，它的功能相当于 Linux 中的命令 `cp`。即文件复制操作。

例如：

```shell
$ mycp file1 file2
```

上面的命令，相当于将文件 file1 复制一份，并命名为 file2。

如果你在执行 `mycp` 的时候报错，提示你没有这个命令，那是因为在系统的 PATH 变量中没有配置环境变量路径。你可以使用

```shell
$ ./mycp file1 file2
```

来执行你的程序。

最后你的文件夹是这样的：

```
{YourName}
├── Makefile
└── mycp.c
```

**在这个任务里，你不必再写自己的 Makefile，从 `allen/Makefile` 把文件复制到你的文件夹下面就行了。**

当你使用了我提供的 Makefile，后一旦执行 make 命令，程序就会自动编译你的程序，并执行 mycp 命令，将本 README.md 文件复制到你的目录下面并命名为 file。你可以通过对比这个 file 文件中的内容，是否和本 README.md 完全一致。


### 4. 扩展阅读

如果你对今天所讲述的几个函数通过查阅文件实在看不明白，这里有一份[扩展阅读资料(https://blog.csdn.net/q1007729991/article/details/52563279)，但是请你不要照抄上面的程序。