## 003_copy

经过一周的练习，不知道你和**系统调用**这位小伙伴的关系搞好没。和它做好朋友，你将事半功倍。

从现在开始，我们要正式学习 Linux 中最核心的知识之一——文件 IO.

在学完文件 IO 的知识以后，你就可以自由的使用文件 IO 相关的系统调用来操作各种文件啦。

比如本文的标题 copy，是想让你通过文件 IO 相关的知识实现一个 copy 命令。

### 1. 文件 IO

咱们来谈谈什么是文件 IO。 在 Linux 中，有种说法就是“一切皆文件”。学过 Java 的朋友肯定也会想起，“一切皆对象”。不过这两者之间除了句法是一样的，并没有其它什么关系。

Linux 的这种思想有个好处，即统一接口。这是什么意思呢？我们从文件本身的特性来谈谈。

通常来说，文件具有下面几个特点：

- 可以向它写入字节数据
- 可以从中读取字节数据
- 通常有一个可调节位置的读写指针

再举几个例子：
- 比如说你磁盘上的文件，你可以操作一些函数，向其中写入数据，也可以读取其中的数据。
- 再比如上节你使用 write 函数向屏幕输出字符，在这里，屏幕是一个很特殊的文件。
- 比如键盘，你可以从键盘读取数据，通常键盘被我们称为标准输入。
- 比如网络，你可以从网络中读取数据，也可以向网络中写入数据。

无论你是向屏幕写入数据，还是向文件写入数据，你都可以使用 `write` 这个系统调用。你不必为了区分设备的类型，而调用不同的函数。

无论是从磁盘文件读取数据，还是从键盘读取数据，你都可以使用 `read` 这个系统调用，道理是一样的，Linux 都把它们视为文件。

假如说，以后让你写个 Linux 程序来控制机器人，那道理是不是一样呢？你可以使用 `read`， `write` 函数来控制机器人的动作，是不是非常方便？

Linux 之所以能做到这一点，是因为在内核设置了一层驱动，在驱动程序里，帮你屏蔽了各种细节，因此作为应用层的使用者，根本无需关心驱动层的实现。

所以说，Linux 的一切皆文件的思想，把所有关于 IO 的处理都统一成同一套接口，只需要使用 `read`，`write` 你就可以完成对各种各样的文件类型进行操作了。

### 2. 文件描述符（File Descriptor）

现在我还不打算深入的去讲解“文件描述符”内部的实现原理，我只讲讲它的概念。

文件描述符，通常我们会简单的称其为 fd，也就是 File Descriptor 的缩写，因为在服务器开发里它太常见了。甚至你会经常听到，fd 泄露，fd 暴涨这些奇怪的术语。所以以后我也会使用 fd。

描述符，这个词在计算机领域你以后会经常见到。它通常来说表示某种数据结构，这个数据结构用来描述相关的对象。如果你听说过“进程控制块”，那你可以简单的认为，它是关于进程的描述符。当然，你在 OS 上编程，操作系统当然不会直接把“进程控制块”的指针直接给你用，而是以进程 id 的方式给你使用，这样就屏蔽了内核中相关的细节了。

文件描述符也是一样，在 OS 层面，它只是以一个整数的形式提供给你使用，当你使用系统调用的时候，你把这个整数传递给系统调用，到到 OS 内核，就能根据这个整数找到相关的数据结构，而这个数据结构，正是用来描述文件的。

比如，任务 2 里的 write 第一个参数，你填写的是数字 1，也就是 `STDOUT_FILENO`，当你将此数字传递给 `write`，经过 `int 0x80` 或者 `syscall` 指令陷入内核后，内核中的程序就可以根据数字 1 找到一个数据结构，它里面包含了一些关于屏幕当前相关的信息。你不妨想象在内核中有这样一个关于文件描述符的数组，当你传递数字 1 的时候，内核程序就从数组的第 1 项中取出一块数据，这个数据就包含了关于屏幕的一些信息。

有了 fd，我们就能使用文件 IO 相关的系统调用与文件打交道了。比如你调用 `read(fd, ...)`，一旦 `read` 函数进入内核，内核就可以根据这个 fd 找到对应的数据结构，拿到关于文件的相关信息，比如已经读取的数据偏移量。

### 3. 文件相关的系统调用

本文件你将使用使用到 `open`，`read`，`write`，`close` 这三个函数。

- `open`

如果你想往本地磁盘某个文件写入数据，首先你得拿到这个文件被打开后的 fd，你可以使用 `open` 函数。`open` 函数不仅可以打开文件，也可以用来创建文件。它的使用方式非常丰富，具体你可以使用 `man 2 open` 进行查阅。

例如，你可以通过调用：

```c
int srcfd = open("README.md", O_RDONLY);
```

以只读的方式来打开 README.md 文件，同时 `open` 函数返回一个描述符保存在 `srcfd` 这个变量中。

如果你调用：

```c
int dstfd = open("file", O_CREAT | O_WRONLY, 0666);
```

它表示以只写的方式创建或打开一个名为 "file" 的文件。

很有意思的是，open 函数既可以有两个参数，也可以有三个参数，这取决于你是怎么使用第二个参数的。具体的规则，你可以查阅 man 手册，也可以阅读文末提供的资料。但我希望你能通过阅读文档来解决这些问题。

- `write` 和 `read`

`write` 在上一个任务里，你已经基本了解了它的使用方法。`read` 表示从文件里读取数据，具体使用方法还是使用 `man` 手册来查阅。

- `close`

`close` 表示关闭文件描述符。它的意思是，如果你不再对这个文件进行操作，应该即时的释放掉内核中关于文件描述符相关的资源。如果你只 `open` 而不做 `close`，系统资源将会被耗尽，也就是产生 fd 泄露的问题。

### 4. 任务

完成下面的任务后，最终你的文件夹是这样的：

```
{YourName}
├── README.md
├── Makefile
└── mycp.c
```

#### 4.1 编程

到了最关键的时候了。你需要 `open`，`read`，`write` 和 `close` 这四个系统调用来实现一个程序`mycp`，它的功能相当于 Linux 中的命令 `cp`。即文件复制操作。

例如：

```shell
$ mycp file1 file2
```

上面的命令，相当于将文件 file1 复制一份，并命名为 file2。

如果你在执行 `mycp` 的时候报错，提示你没有这个命令，那是因为在系统的 PATH 变量中没有配置环境变量路径。你可以使用

```shell
$ ./mycp file1 file2
```

来执行你的程序。



**在这个任务里，你不必再写自己的 Makefile，把 `allen/Makefile` 复制到你的文件夹下面就行了。** 但是请你不要复制我写的 mycp.c 文件。

当你使用了我提供的 Makefile，一旦执行 make 命令，程序就会自动编译你的程序，并执行 mycp 命令，将本 README.md 文件复制到你的目录下面并命名为 file。你可以通过对比这个 file 文件中的内容，是否和本 README.md 完全一致。

#### 4.2 问答

请你创建一个 README.md 文件放到你的目录，复制以下内容进去，并回答。（当然你的回答不能与我的示例回答相同。）

```
### 1. 如果 `open` 或者另外几个相关的系统调用执行出错，，你如何找出出错的原因？

答：我会通过百度找错误原因。（这种回答是无法通过的。）

### 2. 你觉得学习本篇有什么困难？

答：我觉得文件描述符难以理解。因为我很想象内核到底是个什么样的存在……

### 3. 你觉得掌握文件 IO 还能做些什么事情？

答：我认为可以使用 `read`，`write` 去写网络程序，开发服务器。……

### 4. 在你的终端执行命令 `ps`，你会看到你当前 bash 的 PID 号（第一行），记下这个 PID，然后再执行 `lsof -p ${PID}`，注意了，请把 ${PID} 替换成你看到的 PID。接下来你会看到 `lsof` 执行的输出结果。描述你看到的现象，你发现了什么？
```

#### 4.3 提示

关于 `open` 这个系统调用它有些复杂，我们以第二个参数 flags 为线索进行记忆。

- flags 是由“必选项+可选项”组合而成。
- 必选项你只需要记忆三个，即 `O_RDONLY`， `O_WRONLY`， `O_RDWR`。
- 可选项就非常多了，比如 `O_CREAT`，`O_APPEND`，`O_EXCL`，`O_TRUNC`，`O_NONBLOCK`。

首先，必选项是你必须掌握和记忆的。而可选项，是可以通过查阅文档来了解其含义的。在我们这个任务中，你只会使用到 `O_CREAT` 这个可选项。而剩下的可选项，是需要你自己以后探索的，比如 `O_NONBLOCK` 就是一个非常重要的可选项，未来的学习中，我们还会遇到它。

### 5. 扩展阅读

如果你对今天所讲述的几个函数通过查阅文档实在看不明白，这里有一份[扩展阅读资料](https://blog.csdn.net/q1007729991/article/details/52563279)，但是请你不要照抄上面的程序。
